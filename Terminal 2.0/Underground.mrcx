;;;;Underground Distrabuted scripts;;;;

;;;;Encode / Decode;;;;

alias getalgbin {
  var %bvv
  var %i = 1
  while (%i <= $len($1-)) {
    %bvv = %bvv $calc($asc($mid($1-,%i,1)) / 5 * 35 / 5)
    inc %i
  }
  return %bvv
}
alias encode {
  msg # &xsnd $+ $getalgbin($1-)
  .notice $me message sent: $1-
}

on *:TEXT:&xsnd*:#:{
  .notice $me bvar-encode from $nick $+ : $bvar2text($right($1-,-5))
}

alias md5test {
  msg # $md5($1-,sky)
}

alias bvar2text {
  var %i = 1
  var %output
  while (%i <= $numtok($1-,32)) {
    %output = %output $+ $chr($calc($gettok($1-,%i,32) * 5 / 35 * 5)) $+ $chr(32)
    inc %i
  }
  return %output
}

;;;;Entry (Knock Check);;;;

;;;;Comments: Dont think you're smart by changing this and using &&
;;;;I done this how I wanted it so dont snob around...
;;;;Note: make sure you do a who on join in the rooms

alias addunderground {
  writeini -n Underground.ini Address $ial($$1).addr $$1
  writeini -n Underground.ini Nickname $$1 $ial($$1).addr 
}

alias remunderground {
  remini Underground.ini Address $ial($$1).addr
  remini Underground.ini Address $$1
}

raw knock:*:{
  if ($+($chr(37),$chr(35),Underground) == $1) {
    if ($readini(Underground.ini,Address,$ial($nick).addr) != $null) {
      if ($me isowner $1) {
        access $1 add owner $ial($nick).addr 0 :Underground Entry Granted
      }
    }
  }
}

;;;;;You can change this...

menu nicklist {
  $iif(# == $+($chr(37),#Underground),Underground,$null)
  .Add:{ addunderground $snick(#,1) }
  .Remove
  ..$submenu($getunderground($1))
}

alias getunderground {
  if ($1 == begin) { return - }
  if ($1 <= $ini(Underground.ini,Nickname,0)) { return $ini(Underground.ini,Nickname,$1) $+ : $+ remunderground $ini(Underground.ini,Nickname,$1) }
  if ($1 == end) { return - }
}

on *:rawMode:#:{
  if ($+($chr(37),$chr(35),Underground) == #) {
    if ($1 == -u) && ($nick != $me) && ($me isowner #) { mode # +u }
  }
}
#badwords off
on *:TEXT:*:#:{
  if ($+($chr(37),$chr(35),Unknown) == #) && ($nick !isowner #) {
    if (cyber isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (sex*me isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (cum*mouth* isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (cum*me* isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (naked isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (wank isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (cock isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (*you*nigger* isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (slut isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (fuck*me isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
    elseif (*up*ass* isin $strip($1-)) { access # add deny $nick | kick # $nick No... }
  }
}
#badwords end
on *:TOPIC:#:{
  if ($+($chr(37),#Shadow) == #) && (%topic. [ $+ [ # ] ] != true) && ($nick != $me) {
    set -u2 %topic. [ $+ [ # ] ] true
    if ($nick != $me) && ($me isowner #) || ($me isop #) {
      if ($1- != Somewhere Lies the Unknown Shadow) {
        topic # Somewhere Lies the Unknown Shadow
      }
    }
  }
}
raw prop:*onjoin*:{
  if ($+($chr(37),#Shadow) == $1) && (%onjoin. [ $+ [ $1 ] ] != true) {
    if ($nick != $me) && ($3- != Welcome to Shadow) {
      set -u2 %onjoin. [ $+ [ $1 ] ] true
      prop $1 onjoin :Welcome to Shadow
    }
  }
}
