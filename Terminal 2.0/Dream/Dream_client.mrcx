;######Dream - Splitbot coded by Sky######

;Protection by Sky

alias addProtection {
  writeini -n Protection.ini Nickname $1 True
  writeini -n Protection.ini Address $hget(Address,$1) True
}

alias remProtection {
  remini Protection.ini Nickname $1
  remini Protection.ini Address $hget(Address,$1)
}

alias addProtectionHalt {
  writeini -n Protection.ini Halt $hget(Address,$1) $1
}

alias remProtectionHalt {
  remini Protection.ini Halt $hget(Address,$1)
}

menu status {
  .Protection
  ..Add:{ addProtection $$?"Please enter in the nickname you wish to protect." }
  ..Halt:{ addProtectionHalt $$?"Please enter in the nickname you wish to protect." }
  ..Remove
  ...$submenu($getProtection($1))
  ..RemoveHalt
  ...$submenu($getHaltProtection($1))
}
alias getProtection {
  if ($1 == begin) { return - }
  if ($1 <= $ini(Protection.ini,Nickname,0)) { return $ini(Protection.ini,Nickname,$1) $+ : $+ remProtection $ini(Protection.ini,Nickname,$1) }
  if ($1 == end) { return - }
}
alias getHaltProtection {
  if ($1 == begin) { return - }
  if ($1 <= $ini(Protection.ini,Halt,0)) { return $readini(Protection.ini,Halt,$ini(Protection.ini,Halt,$1)) $+ : $+ remProtectionHalt $ini(Protection.ini,Halt,$1) }
  if ($1 == end) { return - }
}

alias -l msn.decode {
  var %r, %l 1
  %r = $replace($1-,ï‚,B,ï‚ ,-,ï€>,-,ï€‹,-,ï€,-,ï…,E,ïƒ,C,ï,A,ï’,R,ï‹,K,ï¹,y,ïº˜,i,ïº‰,s,ï¬³,t,ï¬¸,u,ï»‰,e,ï«,k,ï†,F,ïµ,u,ï§,g,Î§,X,ï€¾,>,ï€¥,$chr(37),ï€¸,8,ï¤,d,ï­,m,ï¨,h,ï»›,s,ï‡,G,ï,M,ï¬,l,ï³,s,ïŸ,_,ï”,T,ï²,r,ï¡,a,ï®,n,ï£,c,ï¥,e,ï,N,ï¡,a,ï´,t,ï©,i,ï¯,o,ï®,n,ï¦,f,ï·,w,ïœ,\,ï¼,|,ï€,@,ï,P,ï„,D,ï€§,',ï€ , ,ï€¨,$chr(40),ï€©,$chr(41),ï€ª,*,ï€º,:,ï›,[,ï,],ï°,p,ï€®,.)
  %r = $replace(%r,Ï‡,X,Å†,n,Î©,n,»·,y,Ñ€,p,Ğ ,P,Å™,r,Ñ…,x,Ä®,I,Ä»,L,Ğ¤,o,Äˆ,C,Å,o,Å©,u,Å„,n,Ä¢,G,Å•,r,Å›,s,Ä·,k,Å–,R,×–,i,Îµ,e,×§,r,Ñ›,h,Ğ¼,m,ØŒ,·,Ä«,i,â€˜,‘,â€™,’,Û±,',Ä“,e,Â¢,¢,ï“,S,â€¢,•,ï,O,ï‰,I,Î†,A,ÑŠ,b,ŠÏ,T,Î¦,o,Ğ‚,b,Ñ,r,Ğ,E,Ğ´,A,Ğš,K,Ä,D,Ğ¸,n,Î¸,o,Ğœ,M,Ğ‡,I,Ğ¢,T,Ğ„,e,Çº,A,Ã¶,ö,Ã¤,ä,â€“,–,Â·,·,Ã–,Ö,Ãœ,Ü,Ã‹,Ë,Ñ•,s,Ä…,a,Ä­,i,Ğ¹,n,Ğ²,b,Ğ¾,o,Ñˆ,w,Ä,G,Ä‘,d,Ğ·,e,Å¦,T,Î±,a,ÄŸ,g,Ãº,ú,Å”,R,Ä„,A,Ä‡,c,Ä,Ğ,Îš,K,Ñ,y,Âµ,µ,Ã,Í,â€¹,‹,Â¦,¦,Ã•,Õ,Ã™,Ù,Ã€,À,Î ,N,Ò“,f,Î°,u,Ä¿,L,Å,o,Ï‚,c,Ä‹,c,Ä§,h,Ä¯,i,Å§,t,Î–,Z,Ã,Ş,Ã¾,ş,Ã§,ç,Ã¡,á,Â¾,¾,Å¾,,Ã‡,Ç,Â $+ $chr(173),-,Ã,Á,â€¦,…,Â¨,¨,Ã½,ı,Ë‰,¯,â€,”,Ã›,Û,Ã¬,ì,Ï,p,Î­,e,Ğ³,r,Ã ,à,Ãˆ,È,Â¼,¼,Äµ,j,Ã£,ã,Ä™,e,ÅŸ,s,Âº,º,Ã‘,Ñ,Ã£,ã,Ã†,Æ,Ëš,°,Ğ¯,R,Ëœ,˜,Ã,Î,ÃŠ,Ê,Ã,İ,Ã,Ï,Ã‰,É,â€¡,‡,ÃŒ,Ì,Âª,ª,Ã³,ó,â„¢,™,Ã’,Ò,Ã­,í,Â¿,¿,Ã„,Ä,Â¶,¶,Ã¼,ü,Æ’,ƒ,Ã°,ğ,Ã²,ò,Ãµ,õ,Â¡,¡,Ã©,é,ÃŸ,ß,Â¤,¤,Ã—,×,Ã´,ô,Å ,Š,Ã¸,ø,â€º,›,Ã¢,â,Ã®,î,â‚¬,€,Å¡,š,Ã¯,ï,Ã¿,ÿ,Åƒ,N,Â©,©,Â®,®,Ã»,û,â€ ,†,Â°,°,Â§,§,Â±,±,Â²,²,Ã¨,è)
  %r = $replace(%r,Å‡,N,Û°,·,Ä´,J,Ğ†,I,Î£,E,Î¹,i,Å,O,Î´,o,×¥,y,Î½,v,×¢,y,×,n,Å½,,Å‘,o,ÄŒ,C,Ä—,e,â‚¤,L,ÅŒ,O,Î¬,a,Ä ,G,â„¦,O,Ğ,H,á»ƒ,e,áºµ,a,Ğ–,K,á»,e,áº¿,e,á»—,o,Å«,u,â‚£,F,âˆ†,a,áº®,A,á»§,u,Ä¶,K,Å¤,T,Å,S,Î˜,O,Ğ¨,W,Î’,B,ĞŸ,N,áº…,w,ï»¨,i,ï¯¼,s,ÑŸ,u,Ñ’,h,Â¹,¹,á»²,Y,Î»,a,Ğ¡,C,Ğ $+ $chr(173),E,Å°,U,Äª,I,Ä,c,Ä”,E,Åœ,S,á»Š,I,Ä,g,Å€,l,Ñ—,i,Ù­,*,Å‰,n,Ä¦,H,Ğ”,A,Îœ,M,Ñ‘,e,Ğ¦,U,Ñ,e,â€œ,“,Ñ„,o,Ñƒ,y,Ñ,c,Ğº,k,Ã…,Å,Æ¤,P,â„,R,ï “,I,É³,n,Ê—,c,â–«,·,Ñ“,r,á»‡,e,áº¯,a,áº³,a,Å¯,u,Ä½,L,Æ°,u,Î‡,·,Ë™,',Î·,n,â„“,l,Â,,Â,,Â,,×€,i,Ä¡,g,Å´,W,Î”,A,ï®Š,J,Î¼,µ,Å¸,Ÿ,Ä¥,h,Î²,ß,Ğ¬,b,Å³,u,Ñ”,e,Ï‰,w,ÄŠ,C,Ñ–,i,Å‚,l,Ç¿,o,âˆ«,s,Å¼,z,Å£,t,Ã¦,æ,â‰ˆ,=,Å,L,Å‹,n,Ú¯,S,Ä,d,Ïˆ,w,Ïƒ,o,Ä£,g,Î‰,H,Î,i,Ò‘,r,Îº,k,ÅŠ,N,œ,\,ï€¯,/,Â¬,¬,Ñ‰,w,Û•,o,×,o,Â³,³,Â½,½,Ä°,I,Ä¾,l,Ä•,e,Å¢,T,Å,s,Å·,y,Ä¾,l,Ä©,i,Ã”,Ô,Åš,S,Ä¹,L,Ğ°,a,Ğµ,e,Î¡,P,Ğˆ,J,Î,N,Ç»,a,Ñ’,h,Î®,n,Î¯,l,Å’,Œ,Â¯,¯,Ä,a,Åµ,w,Ã‚,Â,Ãƒ,Ã,Ğ½,H,Ë‡,',Â¸,¸,Ì£,$chr(44),Ø·,b,Ã“,Ó,Ğ™,N,Â«,«,Ã¹,ù,Ã˜,Ø,Ãª,ê)
  %r = $replace(%r,Ø§,I,Ğ»,n,Ñ‹,bl,Ğ±,6,×©,w,â€•,-,Îª,I,ï ,`,Å­,u,á»•,o,Ç¾,Ø,áº«,a,áº§,a,ï±,q,áº‚,W,Ä¤,H,á»,o,âˆ’,-,ï,^,à¸¥,a,Äœ,G,ïº¯,j,Ù‰,s,Ğƒ,r,á»©,u,â—,·,Ï,u,ï€°,0,ï€·,7,ï€¢,",Ó©,O,Ç,i,Ç‘,O,Æ ,O,ï€²,2,Ò¯,y,ï¶,v,Ğ,A,â‰¤,<,â‰¥,>,áº©,a,ïˆ,H,Ù¤,e,ïº‚,i,ĞŒ,K,Åª,U,ï€»,;,Äƒ,a,Ä¸,k,Ä†,C,Ä¬,I,Åˆ,n,Ä¨,I,Î™,I,Î«,Y,ïŠ,J,ï˜,X,ï½,$chr(125),ï»,$chr(123),Î,E,Ë†,^,ï–,V,ïŒ,L,Î³,y,ïº,i,Î,o,á»³,y,Ä†,C,Ä¬,I,Ä¸,k,Å¶,y,à¹›,c,á»¡,o,à¹“,m,ïº„,i,ï­,G,Å¬,U,Ä’,E,Ä‚,A,Ã·,÷,Â , ,â€š,‚,â€,„,Ë†,ˆ,â€°,‰,Äƒ,a,ï¸,x,ï€½,=,Ù‚,J,ï€¿,?,ï¿¼,-,â—Š,o,Ñ‚,T,Ä€,A,ï­‡,P,Ä–,E,Ä˜,E,Î¿,o,Ï‹,u,â€¼,!!,×˜,u,ï®’,S,Ğ§,y,Ò,r,Ä›,e,Ä˜,E,Äº,I,Î›,a,Î¿,o,Ãš,Ú,Å˜,R,Æ¯,U,Å“,œ,ï€­,-,â€”,—,à¸«,n,à¸ª,a,à¸,s,Î¨,Y,áºª,A,Ï€,n,Å…,N,Ø!,o,Ğ‹,h,á»£,o,Ä‰,c,â—¦,·,ï®,S,Å²,U,Ğ•,E,Ğ…,S,Ûµ,o,ÙŠ,S,Ø¨,u,Ø©,o,Ø¦,s,Ä¼,l,Ä±,i,Å—,r,Ğ¶,x,Î…,",Ï,w,â–ª,·,Î¶,l,Ğ©,W,à¸¿,B,á»¹,y,ÏŠ,i,Å¥,t,Ğ¿,n,Â´,´,Ú©,s,ï±¢,*,Î¾,E,Ñœ,k,âˆš,v,Ï„,t,Ã,Ğ,Â£,£,Ã±,ñ,Â¥,¥,Ã«,ë,Ã¥,å,ï™,Y,Ç,a)
  %r = $replace(%r,áº±,a,â€‚, ,ÎŸ,O,â‚ª,n,áº¬,A,ï‚£,£,ïƒ ,à,ï‚®,®,ïƒ¡,á,ï‚©,©,ïƒµ,õ,á»,o,â€, ,Ö±,¸,Ö¾,-,ï¬´,n,Åº,z,â€Œ, ,Ù,',à¹˜,c,à¸…,m,Â,,ï€¼,<,â–¼,v,ï»œ,S,â„®,e,Åº,z,áº­,a,à¹‘,a,ï¬,fi,ÑŒ,b,ïº’,.,ïºœ,:,à¸¨,a,à¸ ,n,à¹,o,à¸°,=,ï­†,y,à¸‹,i,â€¾,¯,âˆ‚,a,ï¼š,:,â‰ ,=,ï€«,+,Ù…,r,á»“,o,á»¬,U,Ğ›,N,Ó’,A,á»Œ,O,áº„,W,á»´,Y,ïºš,u,ïº¬,i,ïº,u,Å»,Z,ï®•,S,ïº³,w,ï¯½,u,ïº±,uw,ï»š,J,ïº”,a,ï€¡,!,á»…,e,Ù„,J,Ø±,j,Ù€,_,ÏŒ,o,â‚«,d,â„–,no,á»¯,u,Äš,E,Ï†,o,ï» ,I,Ñ†,u,ïƒ…,A,ïƒ‘,N,ĞŠ,H,Îˆ,E,ï¾,~,ï•,U,áº¡,a,ï€±,1,ï€´,4,ï€³,3,á»‰,i,Î•,E,Ğ,U,Ùƒ,J,â˜…,*,ï¢,b,ï€£,$chr(35),ï€¤,$,â—‹,o,Ñ,10,á»µ,y,áº,w,Ò›,k,Ù¿,u,â™‚,o,ï­Š,n,Ù¥,o,ï®,S,â¿,n,ï»—,9,ï¢,b,ï€£,$chr(35),ï€¤,$,â—‹,o,Ñ,10,á»‹,i,Î‘,A,â€€, ,ï»©,o,ï»,E,Ù†,u,áº½,e,Ø«,u,ã…“,t,Ó›,e,Ó˜,E,ï»˜,o,Û·,v,ï¬ª,w,á»¥,u,Å,O,Â,,á»±,u,ï¼ª,J,ï½…,e,ï½,a,ï¼®,N,ï¼ˆ,$chr(40),ï¼ ,@,ï½€,`,ï¼,.,â€²,',ï¼‰,$chr(41),â–¬,-,â—„,<,â–º,>,âˆ‘,E,Ö»,$chr(44),â€¬,|,â€,|,â€ª,|,â€«,|,á»˜,O,Ğ˜,N,ï—,W,ïº,z)
  %r = $replace(%r,×¡,o,â•³,X,Ù ,·,Ò’,F,Ï…,u,â€,,Ö¼,·,Ç”,u,à¸œ,w,áº°,A,áº¤,A,Â»,»,ïº–,u,á»‘,o,ï®“,S,á»Ÿ,o,ïº•,u,ï®”,S, Òœ,K,â™¦,·,â€—,_,ï»ˆ,b,à¸¬,w,ï¬°,x,ï‚­,-,à¸‚,u,à¸—,n,á»œ,O,áº¶,A,á»­,u,á»„,E,à¨¹,J, Ù‡,o,â– ,·,Æ¡,o,ï¿,,Ò£,h,Òš,K,Ò²,X,Ò³,x,Òœ,K,Ø¹,E,Ú†,c,Ñ‡,y,Ğ¥,X,Ù¦,7,Ö½,.,Ù,',Ö¿,',×ƒ,:,á»,o,Ò–,X,ÛŒ,s,à¸¬,w,âˆ™,·,Î¤,T,â“’,c,â“,a,â“Ÿ,p,â“”,e,â“£,t,Ç,A,Ğ¥,X,Ö³,.,ÛŒ,s,á»ˆ,I,Ì‰,',ïš,Z,á»,o,áº¹,e,Ò,k,ïº–,u,á»‘,o,ï®“,S,á»Ÿ,o,ïº•,u,Òš,K,ïš,Z,Ì•,',â”œ,|,â”¤,|,Ø£,I,Â‹,,×,x,áº·,a,Ç’,o,á»œ,O,â˜¼,¤,×,.,ïš,Z,à¸¤,n,â‘·,4,â‘µ,2,â’ª,0,à¹€,i)
  return %r
}


;;;CORE CODE;;;
;MSN OCX Source Code Converted to mIRC code -- Thanks to sid.

;NEW
; // ocx.mrc - original code by sid

alias passportInitPackage {

  ; // returns the initial passport AUTH package

  return $+( IRCVERS IRC8 MSNTV-TELCO, $crlf, AUTH GateKeeperPassport I :GKSSP\0\0\0, $chr(2), \0\0\0, $chr(1), \0\0\0 )
} 

alias guestInitPackage {

  ; // returns the initial guest AUTH package

  return $+( AUTH GateKeeper I :GKSSP\0\0\0, $chr(2), \0\0\0, $chr(1), \0\0\0, $crlf, IRCVERS IRC8 MSNTV-TELCO  )
}

alias authPackageS {

  ; // returns the second AUTH package of the sequence

  return $+( AUTH 0 S GKSSP\0\0\0, $chr(2), \0\0\0, $chr(3), \0\0\0 ) 
}

; // constructor

alias -l ocx {

  ; // initialises values

  if ( !$hget(ocx).size ) {
    ; // if the table doesn't exist - make it

    .hmake ocx 100
  }
}

; // global functions

alias ocxMD {

  ; // digests a string in md5 encryption with the OCX's two keys
  ; // ( ascii string ) : ascii string

  var %string
  %string = $$1
  %string = $escBin(%string)

  var %max
  %max = $numtok( %string, 32 )
  %string = $gettok( %string, $+( $calc( %max - 7 ), - %max ), 32 )
  %string = $keyOne %string
  bset &md5 1 %string
  %string = $md5( &md5, 1 )
  %string = $hexToBin(%string)
  %string = $keyTwo %string
  bset &md5 1 %string
  %string = $md5( &md5, 1 )
  %string = $hexToBin( %string, 1 )
  return %string
}

; // global constants

alias -l ascToHex {

  ; // turns ascii into hex
  ; // ( ascii string, OPTIONAL escapeCharacters = 0 ) : hex string

  var %string, %esc
  %string = $$1
  %esc = $2

  var %counter, %length, %character, %hex
  %counter = 1
  %length = $len(%string)
  %hex = ""

  if ( %esc ) {
    ; // process escape characters

    while ( %counter <= %length ) {
      %character = $asc($mid( %string, %counter, 1 ))
      if ( %character == 92 ) {
        ; // if it's an escape character

        %character = $mid( %string, %counter, 2 )
        if ( %character == \0 ) {
          ; // null character - 00 

          %hex = $+( %hex, 00 ) 
        }
        elseif ( %character == \t ) {
          ; // tab character - 09

          %hex = $+( %hex, 09 )
        }
        elseif ( %character == \n ) {
          ; // newline character - 10

          %hex = $+( %hex, 0A )
        }
        elseif ( %character == \r ) {
          ; // carriage return character - 13

          %hex = $+( %hex, 0D )
        }
        elseif ( %character == \b ) {
          ; // space character - 20

          %hex = $+( %hex, 20 )
        } 
        elseif ( %character == \c ) { 
          ; // comma character - 2C

          %hex = $+( %hex, 2C ) 
        } 
        elseif ( %character == \\ ) {
          ; // backslash character - 5C

          %hex = $+( %hex, 5C )
        }
        inc %counter 2
      }
      else {
        ; // if it's a normal character

        %hex = $+( %hex, $base( %character, 10, 16 ) )
        inc %counter
      }
    }
    return %hex
  }

  else {
    ; // don't process escape characters

    while ( %counter <= %length ) {
      %character = $asc($mid( %string, %counter, 1 ))
      %hex = $+( %hex, $base( %character, 10, 16 ) )
      inc %counter 
    }
    return %hex
  }
}

alias -l hexToAsc {

  ; // turns hex into ascii with escape characters
  ; // ( hex string ) : ascii string

  var %string
  %string = $$1

  var %counter, %length, %character, %asc
  %counter = 1
  %length = $len(%string)
  %asc = ""

  while ( %counter <= %length ) {
    %character = $mid( %string, %counter, 2 )
    if ( %character == 00 ) {
      ; // null character - \0

      %asc = $+( %asc, \0 )
    }
    elseif ( %character == 09 ) {
      ; //tab character - \t 

      %asc = $+( %asc, \t )
    }
    elseif ( %character == 0A ) {
      ; // newline character - \n 

      %asc = $+( %asc, \n )
    }
    elseif ( %character == 0D ) {
      ; // carriage return character - \r 

      %asc = $+( %asc, \r )
    }
    elseif ( %character == 20 ) {
      ; // space character - \b 

      %asc = $+( %asc, \b )
    }
    elseif ( %character == 2C ) {
      ; // comma character - \c

      %asc = $+( %asc, \c )
    }
    elseif ( %character == 5C ) {
      ; // backslash character - \\

      %asc = $+( %asc, \\ )
    }
    else {
      ; // normal character

      %asc = $+( %asc, $chr($base( %character, 16, 10 )) )
    }
    inc %counter 2
  }
  return %asc
}

alias -l bin {

  ; // turns an ascii string into a binary string
  ; // ( ascii string ) : binary string

  var %string
  %string = $$1 

  var %counter, %length, %bin, %character
  %counter = 1
  %length = $len(%string)
  %bin = ""

  while ( %counter <= %length ) {
    %character = $asc($mid( %string, %counter, 1 ))
    if ( %character == 92 ) {
      ; // if it's an escape character

      %character = $mid( %string, %counter, 2 )
      if ( %character == \0 ) {
        ; // null character - 0

        %bin = %bin 0
      }
      elseif ( %character == \t ) {
        ; // tab character - 9

        %bin = %bin 9
      }
      elseif ( %character == \n ) {
        ; // newline character - 10 

        %bin = %bin 10
      }
      elseif ( %character == \r ) {
        ; // carriage return character - 13

        %bin = %bin 13
      }
      elseif ( %character == \b ) {
        ; // space character - 32

        %bin = %bin 32
      }
      elseif ( %character == \c ) {
        ; // comma character - 44 

        %bin = %bin 44
      }
      elseif ( %character == \\ ) {
        ; // backslash character - 92

        %bin = %bin 92
      }
      inc %counter 2
    }
    else { 
      ; // if it's a normal character

      %bin = %bin %character
      inc %counter
    }
  }
  return %bin
}

alias -l hexToBin {

  ; // converts hex to a binary string
  ; // ( hex, OPTIONAL escapeCharacter = 0 ) : bin

  var %string, %esc
  %string = $$1
  %esc = $2

  var %counter, %length, %character, %bin
  %counter = 1
  %length = $len(%string)
  %bin = ""

  if ( %esc ) { 
    ; // include escape characters

    while ( %counter <= %length ) {
      %character = $mid( %string, %counter, 2 )

      if ( %character == 00 ) {
        ; // null character - \0

        %bin = %bin 92 48
      }
      elseif ( %character == 09 ) { 
        ; // tab character - \t 

        %bin = %bin 92 116
      }
      elseif ( %character == 0A ) { 
        ; // newline character - \n

        %bin = %bin 92 110
      }
      elseif ( %character == 0D ) { 
        ; // tab character - \r

        %bin = %bin 92 114 
      }
      elseif ( %character == 20 ) { 
        ; // space character - \b

        %bin = %bin 92 98
      }
      elseif ( %character == 2C ) { 
        ; // comma character - \c 

        %bin = %bin 92 99
      }
      elseif ( %character == 5C ) { 
        ; // backspace character - \\

        %bin = %bin 92 92 
      }
      else {
        ; // normal character

        %bin = %bin $base( %character, 16, 10 )
      }
      inc %counter 2
    }
    return %bin
  }

  else {
    ; // don't include escape characters

    while ( %counter <= %length ) {
      %character = $mid( %string, %counter, 2 )
      %bin = %bin $base( %character, 16, 10 )
      inc %counter 2
    }
    return %bin
  }
}

alias -l escBin {

  ; // replaces escape characters in a binary ascii string with normal ascii values
  ; // ( binary string ) : bin

  var %string
  %string = $$1

  bset &string 1 %string
  bset &bin 1 0 0 0 0 0 0 0 0

  var %counter, %length, %character, %bpos
  %counter = 1
  %length = $bvar( &string, 0 )
  %bpos = 1

  while ( %counter <= %length ) {
    %character = $bvar( &string, %counter )

    if ( %character == 92 ) {
      ; // if it's an escape character

      %character = $bvar( &string, $calc( %counter + 1 ) )
      if ( %character = 48 ) {
        ; // null character - 0

        bset &bin %bpos 0
      }
      elseif ( %character == 116 ) {
        ; // tab character - 9

        bset &bin %bpos 9
      }
      elseif ( %character == 110 ) {
        ; // newline character - 10

        bset &bin %bpos 10
      }
      elseif ( %character == 114 ) {
        ; // carriage return character - 13

        bset &bin %bpos 13
      }
      elseif ( %character == 98 ) {
        ; // space character - 32

        bset &bin %bpos 32
      }
      elseif ( %character == 99 ) {
        ; // comma character - 44

        bset &bin %bpos 44
      }
      elseif ( %character == 92 ) {
        ; // backspace character - 92

        bset &bin %bpos 92
      }
      inc %counter 2 
    }
    else {
      ; // if it's not an escape character

      bset &bin %bpos %character
      inc %counter
    }
    inc %bpos
  }
  %length = $bvar( &bin, 0 )
  return $bvar( &bin, 1, %length )  
}

; // local constants

alias -l keyOne {

  ; // returns the first key

  return 101 100 112 123 125 101 124 119 120 114 100 115 101 125 125 117 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54 54
}

alias -l keyTwo {

  ; // returns the second key

  return 15 14 26 17 23 15 22 29 18 24 14 25 15 23 23 31 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92 92
}

; // attribute methods

; // main attribute access methods

alias -l set_ { .hadd ocx $$1 $$2 }
alias -l get_ { return $hget( ocx, $$1 ) }


; // end script

alias -l GateClone {
  var %i, %o, %int, %c
  %i = $1-
  %i = $left( %i, 32 )
  %i = $+( $str( 0, $calc( 32 - $len( %i ) ) ), %i )
  %i = $+( $mid( %i, 7, 2 ), $mid( %i, 5, 2 ), $mid( %i, 3, 2 ), $mid( %i, 1, 2 ), $mid( %i, 11, 2 ), $mid( %i, 9, 2 ), $mid( %i, 15, 2 ), $mid( %i, 13, 2 ), $mid( %i, 17 ) )
  %i = $iif( %i == $str( 0, 32 ), $+( $str( 0, 31 ), 1 ), %i ) 
  %int = 1
  while ( %int <= $len(%i) ) { 
    %c = $mid( %i, %int, 2 ) 
    %o = $+( %o, $toEscNum( , $mid( %i, %int, 2 ) ) )
    inc %int 2
  }
  return %o
}
alias -l toEscNum {
  var %in 
  %in = $$2 
  %in = $iif( $1, $base( %in, $1, 10 ), $base( %in, 16, 10 ) )
  if ( %in == 0 ) { return \0 }
  elseif  ( %in == 9 ) { return \t }
  elseif ( %in == 10 ) { return \n }
  elseif ( %in == 13 ) { return \r }
  elseif ( %in == 32 ) { return \b }
  elseif ( %in == 44 ) { return \c }
  elseif ( %in == 92 ) { return \\ }
  else { return $chr(%in) }
}
alias -l binary { 
  var %binary
  var %i = 1
  while (%i <= 16) {
    %binary = $+(%binary,$iif($rand(1,0) == 0,\0,$chr(1)))
    inc %i
  }
  return %binary
}
alias -l hex { return $base( $$1, 10, 16 ) }
alias -l rHex { return $hex($r( 0, 15 )) }
alias hexString { return $+( $rHex, $rHex, $rHex, $rHex, $rHex, $rHex, $rHex, $rHex ) }

alias -l hash { return $MD5($hexString) }

alias -l guestform {
  return $mid($1,7,2) $+ $mid($1,5,2) $+ $mid($1,3,2) $+ $left($1,2) $+ $mid($1,11,2) $+ $mid($1,9,2) $+ $mid($1,15,2) $+ $mid($1,13,2) $+ $right($1,16)
}
alias -l passform return $base($len($$1),10,16,8) $+ $1 $+ $base($len($$2),10,16,8) $+ $2

alias r exit | run $mircexe

;dream sock = channels

;;Socket updater by Sky;;

on *:start:{
  ddeserver on BotServ
}

alias sck {
  return $+(dream.,$rand(a,z),$rand(a,z),$rand(a,z),$rand(a,z),$rand(a,z),$rand(a,z),$rand(a,z),$rand(a,z))
}

alias establish {
  if ($sock($hget(channels,$3)).status == active) { 
    /dde Terminal command "" /msg $chr(36) $+ active %mynick Already In Channel Socket $3
    halt
  }
  set %mnick $4
  set %mynick $iif($5,$5,%mnick $+ [Dream])
  echo -a Authenticating to $3 on $1 $+ : $+ $2
  var %x = $sck
  hadd -m sck %x $3
  hadd -m channels $3 %x
  sockopen %x $1 $2
  sockmark %x $3
}

alias closesck {
  $+(.timerkeepalive,$hget(channels,$1)) off
  sockwrite -tn $hget(channels,$1) QUIT : $+ $iif(!$2-,Dream,$2-)
}

alias closeall {
  .timer* off
  sockclose *
}
alias nick {
  set %mynick $1
  sockclose *
}
alias botdeop {
  sockwrite $hget(channels,$1) $+(ACCESS $chr(37),$1 CLEAR OWNER,$lf,PROP $chr(37),$1 OWNERKEY :,$rand(a,z),$rand(a,z),$lf,MODE $chr(37),$1 -q $2,$lf,PROP $chr(37),$1 OWNERKEY :,$rand(a,z),$rand(a,z),$crlf)
}
alias bothop {
  sockwrite $hget(channels,$1) $+(PART $chr(37) $+ $1,$lf,JOIN $chr(37) $+ $1,$crlf)
}
alias botjoin {
  sockwrite $hget(channels,$1) $+(JOIN $chr(37) $+ $1,$crlf)
}
alias botsay {
  sockwrite $hget(channels,$1) $+(PRIVMSG $chr(37) $+ $1 :,$2-,$crlf)
}
alias botkick {
  sockwrite $hget(channels,$1) $+(KICK $chr(37) $+ $1 $2 ,:,$3-,$crlf)
}
alias botmode {
  sockwrite $hget(channels,$1) $+(MODE $chr(37) $+ $1 $2-,$crlf)
}

alias listroom {
  var %i = 1
  while (%i <= $hget($1).size) {
    if (. !isin $hget($1,$hget($1,%i).item)) && ($hget($1,$hget($1,%i).item) != $null) {
      echo -a 4Warning $hget($1,%i).item
      ;sockwrite -tn $hget(channels,$1) KICK $chr(37) $+ $1 :
    }
    inc %i 
  }
}

alias doinvite {
  .timerinvites 0 5 invites $hget(channels,$1)
  /dde Terminal command "" /msg $chr(36) $+ active Mass invite activated.
}

alias recon {
  var %i = 1
  while (%i <= $sock(*,0)) {
    if ($sock(*,%i).mark == $1) {
      sockclose $sock(*,%i)
    }
    inc %i
  }
}

alias keepalive {
  if ($sock($1).status != active) && ($sock($1).status != connecting) { 
    sockopen $1 $2 $3
    sockmark $1 $4
  }
}

on *:sockopen:dream.*:{
  set % [ $+ [ $sockname ] ] [ $+ [ .ticks ] ] $ticks
  $+(.timerkeepalive,$sockname) -m 0 10 keepalive $sockname $sock($sockname).ip $sock($sockname).port $sock($sockname).mark
  sockwrite $sockname $+(NICK %mynick,$lf,$passportInitPackage,$crlf)
}

on *:sockread:dream.*:{
  sockread -n &read
  var %data = $bvar(&read,1,$bvar(&read,0)).text
  tokenize 32 %data
  ;  echo -a %data
  if ($4-5 == -q %mynick) {
    if (%qflood. [ $+ [ $sock($sockname).mark ] ] != true) {
      set -u1 %qflood. [ $+ [ $sock($sockname).mark ] ] true
      var %x = $+(MODE %mynick h %key. [ $+ [ $sock($sockname).mark ] ],$lf,MODE $3 -q $remove($gettok($1,1,33),:),$lf,PROP $3 OWNERKEY :,Dream-,$rand(a,z),$rand(a,z),$rand(a,z),$rand(a,z),$lf,Access $3 clear owner,$lf,access $3 add owner %gate,$lf)
      sockwrite -b $sockname $len(%x) %x
    }
  }
  if ($4-5 == +q %mynick) {
    if (%qwflood. [ $+ [ $sock($sockname).mark ] ] != true) {
      set -u1 %qwflood. [ $+ [ $sock($sockname).mark ] ] true
      sockwrite $sockname $+(PROP $3 OWNERKEY :,Dream-,$rand(a,z),$rand(a,z),$rand(a,z),$rand(a,z),$lf,access $3 add owner %gate,$crlf)
    }
  }
  if ($1 == PING) { sockwrite -tn $sockname PONG $2- }
  if ($2 == MODE) && ($4 == -q) {
    hadd -m $remove($3,:,$chr(37)) $remove($gettok($1,1,33),:) $remove($hget($remove($3,:),$5),.)
  }
  if ($2 == MODE) && ($4 == +q) {
    hadd -m $remove($3,:,$chr(37)) $remove($gettok($1,1,33),:) $remove($hget($remove($3,:),$5),.) $+ .
  }
  if (AUTH GateKeeperPassport S == $1-3) { 
    var %max, %string
    %max = $bvar( &read, 0 )
    %max = %max - 2
    %string = $bvar( &read, $calc( %max - 16 ), 17 )
    %string = $ocxMd(%string)
    bset &auth 1 %string
    sockwrite $sockname $+( AUTH GateKeeper S GKSSP\0\0\0, $chr(2), \0\0\0, $chr(3), \0\0\0 ) 
    sockwrite $sockname &auth
    sockwrite $sockname $+($crlf,AUTH GateKeeperPassport S : $+ $passform(%ticket,%profile),$lf,USER $me * * :15D14r1eam - extention sockbot to Terminal (Auth Time: $calc($calc($ticks - $int(% [ $+ [ $sockname ] ] [ $+ [ .ticks ] ])) / 1000) Secs ),$lf,PROP %mynick SUBSCRIBERINFO $+(:,%sinfo),$lf,GOTO,$chr(32),$chr(37),$sock($sockname).mark %mnick,$crlf)
    unset % [ $+ [ $sockname ] ] [ $+ [ .ticks ] ]
  }
  elseif ($1-3 == Auth GateKeeperPassport *) {
    set %gate $4 
    /dde Terminal command "" /set $+($chr(37),botgate) $4
  }
  elseif ($2 == KICK) {
    if ($readini(Protection.ini,Address,$hget(Address,$4)) == true) && ($readini(Protection.ini,Halt,$hget(Address,$remove($gettok($1,1,33),:))) == $null) && ($nick != %mynick) {
      sockwrite $sockname $+(access $3 clear,$lf,access $3 add deny $hget(Address,$remove($gettok($1,1,33),:)),$lf,kick $3 $remove($gettok($1,1,33),:) :Protected $4,$lf,mode $3 +q $me,$crlf)
    }
  }
  elseif ($2 == JOIN) && ($gettok($1,1,33) == $+(:,%mynick)) {
    sockwrite -tn $sockname WHO $remove($4,:)
  }
  elseif ($2 == JOIN) {
    hadd -m $remove($4,:,$chr(37)) $remove($gettok($1,1,33),:) $remove($hget($remove($4,:),$remove($gettok($1,1,33),:)),$gettok($3,4,44)) $+ $gettok($3,4,44)
    hadd -m Address $remove($gettok($1,1,33),:) $gettok($1,2,33)
    inc -u3 %join. [ $+ [ $sock($sockname).mark ] ]
    if (%join. [ $+ [ $sock($sockname).mark ] ] = 5) {
      var %x = MODE $chr(37) $+ $sock($sockname).mark +i $+ $lf
      sockwrite -b $sockname $len(%x) %x
      %x = $+(ACCESS $chr(37) $+ $sock($sockname).mark CLEAR HOST,$lf)
      sockwrite -b $sockname $len(%x) %x
    }
  }
  elseif ($4 == OWNERKEY) {
    set %key. [ $+ [ $sock($sockname).mark ] ] $remove($5,:)
  }
  elseif ($2 == PART) && ($gettok($1,1,33) == $+(:,%mynick)) {
    hfree $sock($sockname).mark
  }
  elseif ($2 == PART) {
    hdel $remove($3,:,$chr(37)) $remove($gettok($1,1,33),:)
  }
  elseif ($2 == QUIT) {
    if ($hget($remove($3,:,$chr(37)),$remove($gettok($1,1,33),:))) {
      hdel $remove($3,:,$chr(37)) $remove($gettok($1,1,33),:)
    }
  }
  elseif ($2 == KICK) && ($4 == %mynick) {
    sockwrite $sockname $+(JOIN $chr(37),$sock($sockname).mark %key. [ $+ [ $sock($sockname).mark ] ],$lf,KICK $chr(37),$sock($sockname).mark $remove($gettok($1,1,33),:) :Dream,$lf,PROP $chr(37),$sock($sockname).mark OWNERKEY :,Dream-,$rand(a,z),$rand(a,z),$rand(a,z),$rand(a,z),$lf,Access $chr(37),$sock($sockname).mark clear owner,$lf,access $chr(37),$sock($sockname).mark add owner %gate,$crlf)
    hfree $sock($sockname).mark
  }
  elseif ($2 == KICK) {
    hdel $remove($3,:,$chr(37)) $4
  }
  elseif ($2 == KILL) {
    hdel $sock($sockname).mark $3
  }
  elseif ($2 == 352) {
    hadd -m $remove($4,:,$chr(37)) $8 $9
    hadd -m Address $8 $replace($5-6,$chr(32),$chr(64))
  }
}

;;Socket updater by Sky;;

alias update {
  if (!%account) { set %account $$?"Please enter in your email." }
  if (!%password) { set %password $$?"Please enter in your password." }
  getinfo %account %password
  set %udticks $ticks
}

alias -l getinfo {
  sockclose update
  if ($gettok(%account,2,64) == msn.com) {
    sockopen update msnialogin.passport.com 80
    sockmark update $1 $2 msnialogin.passport.com
  }
  elseif ($gettok(%account,2,64) == hotmail.com) {
    sockopen update loginnet.passport.com 80
    sockmark update $1 $2 loginnet.passport.com
  }
  else {
    sockopen update login.passport.com 80
    sockmark update $1 $2 login.passport.com
  }
}

on *:sockopen:update:{
  sockwrite -n $sockname GET /login2.srf HTTP/1.1
  sockwrite -n $sockname Authorization: Passport1.4 OrgVerb=GET,OrgURL=?,sign-in= $+ $gettok($gettok($sock($sockname).mark,1,32),1,64) $+ $chr(37) $+ 40 $+ $gettok($gettok($sock($sockname).mark,1,32),2,64) $+ ,pwd= $+ $gettok($sock($sockname).mark,2,32) $+ ,id=507
  sockwrite -n $sockname Host: $+($gettok($sock($sockname).mark,3,32),$crlf,$crlf)
}

on *:sockread:update:{
  var %data
  sockread %data
  tokenize 32 %data
  if (%data != $null) {
    if ($1 == Authentication-Info:) {
      set %ticket $right($gettok($mid($3,$pos($3,'t=),$len($3)),1,38),-3)
      set %profile $right($gettok($gettok($mid($3,$pos($3,'t=),$len($3)),2,38),1,39),-2)
      set %pauth : $+ $passform(%ticket,%profile)
      render
    }
    elseif ($3 == Unauthorized) {
      conmessage 4Passport details incorrect.
      sockclose $sockname
    } 
  }
}


alias render {
  sockclose renderchat
  sockopen renderchat chat.msn.com 80
}
on *:sockopen:renderchat:{
  sockwrite -n $sockname GET /renderchat.msnw? HTTP/1.1
  sockwrite -n $sockname HOST: chat.msn.com
  sockwrite -n $sockname User-Agent: compatible; MSIE 4.0; Windows NT 4.0
  sockwrite -n $sockname Cookie: MSPAuth= $+ %ticket $+ ; MSPProf= $+ %profile $+ $crlf $+ $crlf
}

on *:sockread:renderchat:{
  sockread -n &read
  if ($sockbr == 0) { return }
  if ($bvar(&read,$bfind(&read, 1, 34 83 117 98 115 99 114 105 98 101 114 73 110 102 111 34),$bvar(&read,0))) { 
    if (SubscriberInfo isin $bvar(&read,$bfind(&read,1,34 83 117 98 115 99 114 105 98 101 114 73 110 102 111 34),$bvar(&read,0)).text) { 
      var %x = $bvar(&read,$bfind(&read,1,34 83 117 98 115 99 114 105 98 101 114 73 110 102 111 34),$bvar(&read,0)).text
      %x = $mid(%x,$pos(%x,VALUE),$len(%x))
      %x = $mid(%x,$calc($pos(%x,") + 1),$len(%x))
      set %sinfo $mid(%x,1,$calc($pos(%x,") - 1))
      echo -s 4Passport update complete for %account in $calc($calc($ticks - %udticks) / 1000) Seconds
      /dde Terminal command "" /msg $chr(36) $+ active 4Passport update complete in $calc($calc($ticks - %udticks) / 1000) Seconds
    }
  }
}

alias invites {
  inc %invite
  if (%invite > 5) { sockclose $1 | set %invite 0 | halt }
  sockwrite -tn $1 INVITE $read(Names.txt)
}

;;;;Dream Engine;;;;
